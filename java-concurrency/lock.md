# Lock

## Synchronized

- 互斥锁
  - 调试： ClassLayout.parseInstance(0).toPrintable()



## 锁升级

轻量级锁 - 自旋锁

- CAS

  - 乐观锁
    - 100++, 写回去的时候，和修改之前的状态一致即可
    - 100++，如果发现改之后，已经有人修改它为 200， 重新来一遍即可
  - ABA
    - 其他线程 100 -》 200 -》 100 
      - 不在乎，的时候， 直接 101
      - 在乎，JVM 里面做了这方面的事情了
        - 加了版本号
          - 1...100
          - false ... true
            - markable
  - 判断后，100 -》 准备修改的时候 -》 被其它的改了

  在 JVM 内部，自旋， while ，线程自己干完（转圈 -》 ）

&nbsp;

重要级锁

JAVA 线程模型

- new Thread() 和 操作系统
  - hotspot 1：1
    - 实现简单
      - 都交给老大 OS 处理 （重要级锁）
      - 所以很重
- go 语言的纤程模型
  - M：N
    - 5（OS） -》 几万个（纤程）

&nbsp;

### 自旋锁一定比重要级锁效率高吗？

不一定

如果线程处理事情时间过长，等待的过多，自旋需要消耗 CPU  contect switch, cpu 用于线程切换了， 这种情况，效率很低， Synchronized 效率可能还高些

&nbsp;

轻量级 -》 重要级锁

- < 1.6 版本，自旋超过 10 次，超过 重要级锁 -XX:PreBlockSpin , since 1.6 版本， JDK 自己优化



&nbsp;

### 偏向锁

JDK 15 已经默认关闭， 可以打开

JDK 8 默认打开

第一个占资源的过程，贴名片

两个线程来了，直接将偏向锁撤销，然后抢资源，进行锁升级。

一个标记为 synchronized 的对象，方法， 70 -80%的时间里，一般都只有一个线程在干活，所以一上来直接自旋或重要级锁，效率低。

明知道有很多线程干活，上偏向锁，效率会慢些，因为需要撤销偏向锁，消耗 CPU 资源

一个 JVM 启动时，大概要启动 11 个线程

启动的过程中，如果要启动偏向锁，加大资源的消耗

所以，默认 JDK 启动4秒后，才会启动轻量级， 如果睡眠5秒， 轻量级锁会被打开



锁降级一般不会出现，仅仅只有 GC 线程访问它时才可能锁降级，但一般这时候，对象处于可回收状态，所以可以认为锁降级不会出现



